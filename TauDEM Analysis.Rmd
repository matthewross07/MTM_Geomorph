---
title: "TauDEM analysis"
author: "Matthew Ross"
date: "May 30, 2017"
output:
  html_document:
    toc: true
    theme: united
---



# TauDEM

This is a script that does terrain analyses using the [TauDEM tool](http://hydrology.usu.edu/taudem/taudem5/index.html) from David Tarboton at Utah State. All scripts below should be run in bash or terminal after installing TauDEM. R Code is mixed throughout to generate a final data table for analysis. 

Some R code is at the bottom of the script to project outlets and subset rasters. 


## Pit remove
```{bash, eval=F}
mpiexec -n 8 pitremove -z TauNew.tif -fel newfel.tif

mpiexec -n 8 pitremove -z TauOldElev.tif -fel oldfel.tif
```

## D8 

### Flow direction with slope and flow direction
```{bash, eval=F}
mpiexec -n 8 d8flowdir -p newdir8.tif -sd8 newsd8.tif -fel newfel.tif

mpiexec -n 8 d8flowdir -p olddir8.tif -sd8 oldsd8.tif -fel oldfel.tif

```

### Flow accumulation
```{bash, eval=F}
#mpiexec -n 8 aread8 -p newdir8.tif -ad8 newuaa8.tif

#mpiexec -n 8 aread8 -p olddir8.tif -ad8 olduaa8.tif
```

 
##  D-Infinity

### Flowdir
```{bash, eval=F}
mpiexec -n 8 dinfflowdir -ang newinffdr.tif -slp newinfslp.tif -fel newfel.tif

mpiexec -n 8 dinfflowdir -ang oldinffdr.tif -slp oldinfslp.tif -fel oldfel.tif


```

### Flow accumulation
```{bash, eval=F}
mpiexec -n 7 areadinf -ang newinffdr.tif -sca newinfuaa.tif

mpiexec -n 7 areadinf -ang oldinffdr.tif -sca oldinfuaa.tif

```


##  UAA analysis

### Threshold 1000 pixels = 0.1 km2

```{bash, eval =F}

#New infinity
mpiexec -n 7 threshold -ssa newinfuaa.tif -src new100inf.tif -thresh 100
#Old infinity 
mpiexec -n 7 threshold -ssa oldinfuaa.tif -src old100inf.tif -thresh 100

#New D8 
mpiexec -n 7 threshold -ssa newuaa8.tif -src new1008.tif -thresh 100
#Old D8
mpiexec -n 7 threshold -ssa olduaa8.tif -src old1008.tif -thresh 100

#Curvature method



```

### Project outlets with same projection as rasters
```{r}

library(raster)
library(tidyverse)
library(magrittr)
library(rgdal)
library(rgeos)
library(shapefiles)
library(maptools)
library(leaflet)
library(velox)
library(foreach)
library(snow)
library(parallel)
library(doParallel)
library(Hmisc)

# proj <- projection(raster('TauNew.tif'))
# outs <- readOGR('shapefile/SubSheds.kml','Sub Sheds',stringsAsFactors=F) %>% spTransform(.,proj)
# outs <- outs[,1]
# outs$Id <- 1:nrow(outs)
# outs <- outs[,2:1]
# plot(outs)x
# 
# writeOGR(outs,'shapefile','approxnew',driver='ESRI Shapefile',overwrite_layer = T)




```




### Move outlets to streams, for some reason this is not working on my computer. 
```{bash, eval=F}

#New Infinity
mpiexec -n 7 moveoutletstostrm -p newinffdr.tif -src new100inf.tif -o shapefile/approxnew.shp -om shapefile/snapinfnew.shp -md 30


```

### Delineate watersheds

```{bash}
#New Infinity
mpiexec -n 7 areadinf -ang newinffdr.tif -o shapefile/approxnew.shp -sca newshedinf.tif

mpiexec -n 7 aread8 -p newdir8.tif -o shapefile/approxnew.shp -ad8 newshed8.tif

mpiexec -n 7 areadinf -ang oldinffdr.tif -o shapefile/approxnew.shp -sca oldshedinf.tif

mpiexec -n 7 aread8 -p olddir8.tif -o shapefile/approxnew.shp -ad8 oldshed8.tif

```



# R analysis



##  Stack and cutup rasters to smaller extents
```{r, eval=F}
#Using a new faster raster library called Velox


#Setup readin paths and crop extents and name order and empty lists
uaa.paths <- c('newshedinf.tif', 'oldshedinf.tif','newshed8.tif','oldshed8.tif')
slope.paths <- c('newinfslp.tif','oldinfslp.tif','newsd8.tif','oldsd8.tif')
e.paths <- c('TauNew.tif','TauNew.tif','TauOldElev.tif','TauOldElev.tif')
old.outlines <- readOGR('shapefile','FinalWshed_All_Whole',stringsAsFactors = F)
old.names <- old.outlines$Site_Name %>% unique(.) %>% sort(.)
uaa.stack <- list()
slope.stack <- list()
e.stack <- list()
esu.stacked <- list()
Evaluate on 5 cores (1 for each site)
cl <- makeCluster(5)
registerDoParallel(cl,cores=5)
all.list <- foreach(i = 1:length(old.names)) %dopar% {
  library(raster)
  library(rgdal)
  library(magrittr)
  #Read in HUC12 Watershed outlines to trim data
  shape <- old.outlines[old.outlines$Site_Name == old.names[i],]
  for(j in 1:length(uaa.paths)){
      #Read in watershed delineations and crop to single watershed
      shed <- raster(uaa.paths[j]) %>% crop(.,shape)
      #Store this cropped watershed uaa tif in a list
      uaa.stack[[j]] <- shed
      #Read in slope raster and crop
      slope <- raster(slope.paths[j]) %>% crop(.,shape)
      #Set Slope values outside of watershed to NA
      slope[is.na(shed)] <- NA
      #Store in slope stack
      slope.stack[[j]] <- slope
      #Samesies with elevation
      e <- raster(e.paths[j]) %>% crop(.,shape)
      e[is.na(shed)] <- NA
      e.stack[[j]] <- e
  }
  esu.stacked[[i]] <- stack(c(e.stack,slope.stack,uaa.stack)) %>% trim(.)
}
endCluster()

names(all.list) <- old.names


save(all.list, file='ras.stack.RData')
```



##  Convert raster data to data frames
```{r}
#Loads in all list which is a list of all sites
load('ras.stack.RData')

library(doParallel) #to do parallel processing
library(parallel) # to register parallel processing
library(foreach) # to do parallel processing as a forloop
#Evaluate on 5 cores (1 for each site)
cl <- makeCluster(3) #make a cluster with 3 cores
registerDoParallel(cl,cores=3) #tell parallel processor to use 3 cores
stack.list <- foreach(i=1:length(old.names)) %dopar% {
  library(raster)
  library(dplyr)
  library(magrittr)
  l <- extract(all.list[[i]]) %>% as.data.frame(.) %>%
    mutate(Site = old.names[i]) 
}
endCluster()

stack.df <- do.call('rbind',stack.list)

#Name the rows of this wide data frame
plot(all.list[[1]])
names(stack.df)[1:4] <- c('New.e.new','New.e.old','Old.e.new','Old.e.old')

save(stack.df,file='UAA.E.Slope.RData')


```


##  Stream network

### Convert network into shapefile using code from [John Baumgartner](https://johnbaumgartner.wordpress.com/2012/07/26/getting-rasters-into-shape-from-r/) note that gdal and python-gdal must be installed (on linux machine)

```{r, eval=F}


gdal_polygonizeR <- function(x, outshape=NULL, gdalformat = 'ESRI Shapefile',
                             pypath=NULL, readpoly=TRUE, quiet=TRUE) {
  if (isTRUE(readpoly)) require(rgdal)
  if (is.null(pypath)) {
    pypath <- Sys.which('gdal_polygonize.py')
  }
  if (!file.exists(pypath)) stop("Can't find gdal_polygonize.py on your system.")
  owd <- getwd()
  on.exit(setwd(owd))
  setwd(dirname(pypath))
  if (!is.null(outshape)) {
    outshape <- sub('\\.shp$', '', outshape)
    f.exists <- file.exists(paste(outshape, c('shp', 'shx', 'dbf'), sep='.'))
    if (any(f.exists))
      stop(sprintf('File already exists: %s',
                   toString(paste(outshape, c('shp', 'shx', 'dbf'),
                                  sep='.')[f.exists])), call.=FALSE)
  } else outshape <- tempfile()
  if (is(x, 'Raster')) {
    require(raster)
    writeRaster(x, {f <- tempfile(fileext='.tif')})
    rastpath <- normalizePath(f)
  } else if (is.character(x)) {
    rastpath <- normalizePath(x)
  } else stop('x must be a file path (character string), or a Raster object.')
  system2('python', args=(sprintf('"%1$s" "%2$s" -f "%3$s" "%4$s.shp"',
                                  pypath, rastpath, gdalformat, outshape)))
  if (isTRUE(readpoly)) {
    shp <- readOGR(dirname(outshape), layer = basename(outshape), verbose=!quiet)
    return(shp)
  }
  return(NULL)
}

sn.new.inf <- raster('new1000.tif')
old.outlines <- readOGR('shapefile','FinalWshed_All_Whole') %>% spTransform(.,projection(sn.new.inf))

# sn.1000 <- crop(sn.new.inf,extent(old.outlines)) 
# sn.1000[sn.1000 < 1] <- NA
# sn.1000.shp <- gdal_polygonizeR(sn.1000)
# sn.1000.clip <- sn.1000.shp[old.outlines,] 
# sn.1000.clip <- gUnaryUnion(sn.1000.clip, id = sn.1000.clip$DN)
# sn.1000.clip$name <- 'data'
# writeOGR(sn.1000.clip,'shapefile','sn.1000.clip',driver='ESRI Shapefile',overwrite_layer = T)

# old.inf <- raster('old100.tif')
# old.inf[old.inf<1] <- NA
# old.1000.shp <- gdal_polygonizeR(old.inf)
# old.100.clip <- old.1000.shp[old.outlines,]
# old.100.clip <- gUnaryUnion(old.100.clip,id=old.100.clip$DN)
# old.100.clip$name <- 'data'
# writeOGR(old.100.clip,'shapefile','old.100.clip',driver='ESRI Shapefile')


z <- raster('oldshed8.tif')  
z1 <- raster('newshed8.tif')

plot(old.outlines)
plot(z,add=T,col='black')


leaflet() %>% addTiles() %>%
  addRasterImage(z)


```


