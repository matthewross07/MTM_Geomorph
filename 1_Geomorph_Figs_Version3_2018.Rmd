---
title: "MTM_Geomorph_Figs3.0"
author: "Matthew Ross"
date: "June 14, 2017"
output: 
  html_document: 
    fig_height: 6
    fig_width: 8
editor_options: 
  chunk_output_type: console
---

# Geomorph open source style

```{r setup,include=F}
library(stringr)
library(raster)
library(tidyverse)
library(rgdal)
library(rgeos)
library(shapefiles)
library(maptools)
library(leaflet)
library(velox)
library(foreach)
library(snow)
library(parallel)
library(doParallel)
library(tidyverse)
library(reshape2)
library(plotly)
library(scales)
library(broom)
library(RcppRoll)
library(zoo)
library(knitr)
library(kableExtra)
library(tidyr)
library(ggpubr)
library(plot3D)
#Set ggplot2 theme
matt_theme <- theme_set(theme_bw())
matt_theme<- theme_update(axis.line = element_line(colour = "black"),
                          panel.grid.major=element_blank(),
                          panel.grid.minor = element_blank(),
                          panel.background = element_blank(),
                          text=element_text(family='sans','plain','black',14,0.5,0.5,0,0),
                          plot.margin=unit(c(6,20,6,2),'pt')
)

makeTransparent = function(..., alpha=0.5) {

  if(alpha<0 | alpha>1) stop("alpha must be between 0 and 1")

  alpha = floor(255*alpha)  
  newColor = col2rgb(col=unlist(list(...)), alpha=FALSE)

  .makeTransparent = function(col, alpha) {
    rgb(red=col[1], green=col[2], blue=col[3], alpha=alpha, maxColorValue=255)
  }

  newColor = apply(newColor, 2, .makeTransparent, alpha=alpha)

  return(newColor)

}

reds <- makeTransparent('red4',alpha=.2)
reds1 <- makeTransparent('red4',alpha=.7)
reds2 <- makeTransparent('red4',alpha=.5)


#Loads stack.df a wide data frame with all rasters for 5 sites
load('data/out/UAA.E.Slope.Ref.RData')
load('data/out/ras.stack.ref.RData')



#Load in the long dataset from above chunk.
#Load in long data
load('data/out/Long.DF.RData')
```


### Convert data to long format

In the following code chunk I load in the data convert it into long data and 
make sensible column names. I then save this file so I don't have to perform 
the operations again. 
```{r,eval=F}


#Add an index column
stack.df$index <- 1:nrow(stack.df)

#Gather data into one long data frame
long.df <- stack.df %>%
  gather(Key,value,-Site,-index,na.rm=T)  %>%
  #Fix whiteoak reference name (currently labeld just white)
  mutate(Site=ifelse(Site=='WhiteRef','WhiteOakRef',Site)) %>%
  #Create a column with watershed delineation data (is it old elevation shed or new elevation shed?)
  #This information is the last word in the key column (new.e.new = new elevation profile with new watershed boundary, old.e.new = old elevation profile with new watershed boundary)
  mutate(shed.type= ifelse(grepl('\\.',Key),str_split_fixed(Key,'\\.',n=3)[,3],NA)) %>%
  mutate(elev.data= ifelse(grepl('\\.',Key),str_split_fixed(Key,'\\.',n=3)[,1],NA)) %>%
  #Column to show what flow direction algorithm was used for calcuation
  mutate(fdr.type = ifelse(grepl('8',Key),'f.8','f.inf')) %>%
  #Elevation does not have a flow direction associated with it
  mutate(fdr.type = ifelse(!is.na(shed.type),'None',fdr.type)) %>%
  #What kind of data is in the column? UAA Slope or Elev?
  mutate(Data=ifelse(grepl('shed',Key),'UAA','Slope')) %>%
  mutate(Data=ifelse(!is.na(shed.type),'Elev',Data)) %>%
  #Relabel 'new' as post-mining and old as pre-mining
  mutate(Data.Source = ifelse(grepl('new',Key) & !grepl('Ref',Site),'Current','Historic')) %>%
  #Split sites between reference and mined
  mutate(Type = ifelse(grepl('Ref',Site),'Unmined','Mined')) %>%
  #Rename treaments for reference to reflect historic dem and current dem
  mutate(Data.Source=ifelse(grepl('Ref',Site) & grepl('new',Key),'Current',Data.Source)) %>%
  mutate(Data.Source=ifelse(grepl('Ref',Site) & grepl('old',Key),'Historic',Data.Source)) %>%
  #Make new column with huc12 watershed name
  mutate(Watershed = gsub('Ref','',Site)) 


dat.check <- long.df %>%
  group_by(Watershed,Type,Data.Source,Site) %>%
  dplyr::summarize(length=n()) 



#save(long.df,file='data/out/Long.DF.RData')


```


## Figure 3. Study Map

```{r}
library(sf)
library(ggthemes)
library(ggpubr)
library(grid)
st_envelope = function(x) st_as_sfc(st_bbox(x))

load('data/out/watersheds.RData')


watersheds <- st_as_sf(shd.shp.names,crs=26917) %>%
  mutate(Site = c('White Oak','White Oak','Laurel', 'Laurel','Spruce','Spruce','Mud','Ben','Mud','Ben'),
         Type=c('Mined','Reference','Reference','Mined','Reference','Mined','Reference','Reference','Mined','Mined')) %>%
  mutate(CENTROID = map(geometry, st_centroid),
    COORDS = map(CENTROID, st_coordinates),
    COORDS_X = map_dbl(COORDS, 1),
    COORDS_Y = map_dbl(COORDS, 2))

boundary <- st_envelope(st_buffer(watersheds,10000))

extent(watersheds)
boundary
#No idea why the extent object wouldn't work. 
e2010 <- raster('data/in/TauNew.tif') %>%
  crop(.,extent(411446,460186,4154384,4221224)) %>%
  aggregate(.,10)
  

eobj <- rasterToPoints(e2010) %>%
  as_tibble() 


#Weird rule where fill =T makes this possible to convert to a sf object. 
wv <- maps::map('state',region=c('west virginia'),fill=T,plot=F) %>%
  st_as_sf() %>%
  st_transform(.,26917)



wv.sub <- wv %>% st_intersection(.,st_envelope(boundary))

wv.inset <- ggplot() + 
  geom_sf(data=wv) + 
  theme(panel.grid.major = element_line(color='transparent')) +
  geom_sf(data=wv.sub,color='red',fill=NA,size=2) + 
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.border=element_blank())

wv.inset
wv.dem <- ggplot() + 
  geom_tile(data=eobj,aes(x=x,y=y,fill=TauNew)) + 
  theme_few(base_size=14) + 
  theme(panel.grid.major = element_line(color='transparent')) +
  geom_sf(data=watersheds,aes(color=Type),fill=NA,size=1) +
  scale_color_manual(values=c('blue','purple4'),name='',guide=F) +
  scale_fill_gradient2(high='blue2',low='red2',mid='gray70',midpoint=600,name='Elev. (m)')+
  xlab('') + 
  ylab('') +
  theme(legend.position=c(0.85,0.49)) +
  geom_text(data=watersheds %>%
              filter(Type=='Reference'),aes(x=COORDS_X,y=COORDS_Y,label=Site),nudge_x=3500, nudge_y=3000,size=4.5)
getwd()

png(filename='Figures2018/fig3_studymap.png',width=5.9,height=6.3,units='in',res=300)
vp <- viewport(width=0.35,height=0.45,x=0.72,y=0.26)
print(wv.dem)
print(wv.inset,vp=vp)
dev.off()
```


# Raw site summaries

Summary statistics (median elevation, total relief, etc...) for each watershed. 

## Percent mining

While we attempted to capture control watersheds that were entirely unmined and mined watersheds that were > 80% mined, there is still variation around the amount of mining in each watershed. Here we use data from a paper by Andrew Pericack and others to find when and where mining occured and we use that layer to asses the mining coverage in each watershed as of 2011, when the post-mining watersheds were generated. 

```{r}


#Read in mining detection layer from Pericack et al., 2018
first.mined <- raster('data/in/FirstMinedCamp.tif') 

#The first raster in the list of rasters (all list) is the elevation profile
#of the current watershed delineation. Use this to get % mining for each site

#Use foreach to speedup the operation. Using 3 cores instead of one
cl <- makeCluster(3)
#Register the cores (starts independent R Sessions)
registerDoParallel(cl,cores=3)
#Run a foreach loop that stores results in a list (pmine.list)
pmine.list <- foreach(i=1:length(all.list)) %dopar% {
  #Have to load in the important libraries for each session
  library(raster)
  library(tidyverse)
  library(rgeos)
  #Read in the raw elevation profile (first in the list)
  ras.raw <- all.list[[i]][[1]] 
  #Project the raster into the first.mined raster projection
  ras <-  projectRaster(ras.raw,crs=projection(first.mined)) 
  #Crop the mined raster
  mine.ras <- first.mined %>%
    crop(.,ras) 
  #Project the raster resolution onto the mine resolution (from 10 to 30m)
  ras.res <- projectRaster(ras,mine.ras)
  #Mask out the areas outside of the watershed
  mine.mask <- raster::mask(mine.ras,ras.res)
  #Get the number of mined pixels 
  ras.area = length(ras.res[!is.na(ras.res)])
  #Get the percent mining (mined pixels/total pixels)
  mine.area = length(mine.mask[mine.mask < 2012])
  pmine=mine.area/ras.area
  #Store this as a data frame. 
  dat <- tibble(pmine=pmine,
                Site=names(all.list)[[i]],
                area=round(length(ras.raw[!is.na(ras.raw)])*100/(1000*1000),1))
}
#End the foreach loop
endCluster()

#Cast the data into a sensible data frame 
pmine.dat <- do.call('rbind',pmine.list) %>%
  mutate(Site=gsub('WhiteRef','WhiteOakRef',Site)) %>%
  mutate(pmine=round(pmine,2)*100) %>%
  dplyr::select(Site,pmine) %>%
  arrange(Site)





```



### Elevation

The elevation profiles of the watersheds change following mining. Summary statistics on changes are calculated here. 
```{r}

#Summarize stats by watershed. 
elev.summary <- long.df %>%
  filter(Data == 'Elev') %>%
  filter(Key %in% c('Old.e.old','New.e.new')) %>%
  group_by(Site,Watershed,Type,Data.Source) %>% 
  dplyr::summarize(max=max(value),
            min=min(value),
            median=round(median(value),0),
            mean=mean(value),
            sd=sd(value),
            area=round(n()*100/(1000*1000),2))%>%
  mutate(relief=max-min) 


#Turn the above long dataset into a wide format. 
e.wide <- elev.summary %>%
  ungroup(.) %>%
  dplyr::select(Site,Type,Data.Source,median) %>%
  spread(Data.Source,median) %>%
  arrange(Site) %>% 
  mutate(elev.change= Current/Historic)%>%
  rename(Current.elev=Current,Historic.elev=Historic)

#Get the area data from above. 
area.wide <- elev.summary %>%
  ungroup(.) %>%
  dplyr::select(Site,Type,Data.Source,area) %>%
  spread(Data.Source,area) %>%
  arrange(Site) %>%
  mutate(area.change= Current/Historic)%>%
  rename(Current.area=Current,Historic.area=Historic)

```


### Slope

Slope changes dramatically in mining landscapes and those changes are calculated here. 

```{r}
#Calculate summary statistics for each watershed and data type 
slope.summary <- long.df %>%
  filter(Data == 'Slope') %>%
  filter(fdr.type=='f.inf') %>%
  group_by(Site,Watershed,Type,Data.Source) %>% 
  dplyr::summarize(max=max(value),
            min=min(value),
            median=round(median(value),2),
            mean=mean(value),
            sd=sd(value)) %>%
  mutate(relief=max-min) 


#Widen that data. 
s.wide <- slope.summary %>%
  ungroup(.) %>%
  dplyr::select(Site,Type,Data.Source,median) %>%
  spread(Data.Source,median) %>%
  mutate(slope.change= Current/Historic)%>%
  arrange(Site) %>%
  rename(Current.slope=Current,Historic.slope=Historic)


```

### Drainage density

Our previous work has identified 1000 pixels has an approximate drainage area for the initiation of channels. 
```{r}

drainage.density <- long.df %>%
  filter(Data == 'UAA') %>%
  filter(fdr.type=='f.inf') %>%
  group_by(Site,Watershed,Type,Data.Source) %>% 
  dplyr::summarize(drainage.length = length(which(value > 1000)),
                   drainage.area=n(),
                   drainage.density=round(drainage.length/drainage.area,3))



d.wide <- drainage.density %>%
  ungroup(.) %>%
  dplyr::select(Site,Type,Data.Source,drainage.density) %>%
  spread(Data.Source,drainage.density) %>%
  mutate(DD.change= Current/Historic)%>%
  arrange(Site) %>%
  rename(Current.DD=Current,Historic.DD=Historic)


```





##Total summary 
```{r}
site.summary <- pmine.dat %>%
  left_join(e.wide,by=c('Site')) %>%
  left_join(area.wide,by=c('Site','Type')) %>%
  left_join(s.wide,by=c('Site','Type'))  %>%
  left_join(d.wide,by=c('Site','Type'))

write_csv(site.summary,path='Figures2018/SiteSummary.csv')
```


# Process Zones with Slope Area and Cumulative Area Distribution


## UAA Slope Cutting

```{r}
#keep only f.inf data
#Reference sites are slightly smaller on average so they need a smaller value for switching bin width from lots per bin (1000) to fewer (100)

uaa.small <- long.df %>%
  dplyr::filter(fdr.type=='f.inf') %>%
  dplyr::filter(Data!='Elev') %>%
  #Sites less than 6km2 get smaller cut break
  select(Site,Type,Data,Data.Source,value,index) %>%
  spread(key=Data,value) %>%
  dplyr::filter(UAA <= 6*1000*1000) %>%
  mutate(area.m2 = round(UAA*10,0)) %>%
  group_by(Site,Data.Source) %>%
  mutate(area.bins = ifelse(area.m2 < 20000,Hmisc::cut2(area.m2,m=200),Hmisc::cut2(area.m2,m=50))) %>%
  ungroup() %>%
  group_by(Site,Type,Data.Source,area.bins) %>%
  dplyr::summarize(sd.slope=sd(Slope,na.rm=T),
                  Slope=mean(Slope),
                   n=n(),
                    UAA=mean(area.m2))




#only change here is cut point for switching bin width size
uaa.big <- long.df %>%
  dplyr::filter(fdr.type=='f.inf') %>%
  dplyr::filter(Data!='Elev') %>%
  select(Site,Type,Data,Data.Source,value,index) %>%
  spread(key=Data,value) %>%
  #Sites greater than 6km2 get smaller cut break
  dplyr::filter(UAA > 6*1000*1000) %>%
  mutate(area.m2 = round(UAA*10,0)) %>%
  group_by(Site,Data.Source) %>%
  mutate(area.bins = ifelse(area.m2 < 40000,Hmisc::cut2(area.m2,m=200),Hmisc::cut2(area.m2,m=50))) %>%
  group_by(Site,Type,Data.Source,area.bins) %>%
  dplyr::summarize(sd.slope=sd(Slope,na.rm=T),
                    Slope=mean(Slope),
                   n=n(),
                    UAA=mean(area.m2))

uaa <- bind_rows(uaa.small,uaa.big)


```



### Slope Area Standard Deviation Plots
```{r}

library(ggthemes)

pdf(file='figures2018/SA.SD.pdf',width=10,height=5)
uaa %>%
  ungroup(.) %>%
  mutate(Site = gsub('Ref','',Site)) %>%
  ggplot(aes(x=UAA,y=sd.slope,color=Data.Source)) + 
  geom_point() + 
  facet_grid(Type ~ Site) + 
  scale_colour_few() +
  ylab('SD Slope (m/m)') + 
  theme(legend.position='top',legend.direction = 'horizontal') + 
  scale_y_log10(limits=c(0.01,1)) + 
  xlab(expression(paste('Area (',m^2,')'))) + 
    scale_x_log10(breaks=trans_breaks("log10", function(x) 10^x),
              labels = trans_format("log10", math_format(10^.x))) 
dev.off()


```


##SA Derivative and Smoothing

Detecting zone changes with the raw data detects too many spurious changes related to simple variability. Here we smooth the data using a simple LOESS spline. Then we detect process zones on the smoothed data. 

```{r}

#Make a dataframe with seamless UAA for derivation
full.uaa <- tibble(UAA=10^seq(2,7,.01))

myloess <- function(data){
  mod <- loess(log10(Slope) ~ log10(UAA),span=0.4,data=data)
}



uaa.nest <- uaa %>% 
  group_by(Site,Type,Data.Source) %>%
  nest() %>%
  mutate(mods=purrr::map(data,myloess)) 


uaa.seam <- uaa.nest %>%
  mutate(newdata=full.uaa) %>%
  unnest(newdata) %>%
  rename(UAA=newdata) %>%
  group_by(Site,Type,Data.Source) %>%
  nest() %>%
  rename(newdata=data) %>%
  full_join(uaa.nest,by=c('Site','Type','Data.Source')) %>%
  mutate(pred=map2(mods,newdata,predict)) %>%
  unnest(newdata,pred) %>%
  mutate(pred=10^pred) %>%
  na.omit(.)


uaa.dif <- uaa.seam %>%
  group_by(Site,Type,Data.Source) %>%
  arrange(desc(UAA)) %>%
  mutate(derv=c(NA,diff(log10(pred))/(diff(log10(UAA))))) %>%
  ungroup()




```

## SA Break ID
```{r}
#Using the derivitave data we can automate most of the slope breaks

#Breaks come at 0 value, min value and 
#Use closest from DescTools to get closes value to zero
library(DescTools)
library(strucchange) #Winner winner chicken dinner!
library(doMC)
#Frist breaks are befrore 10^4 by visual inspection. First minimum is generally the biggest minimum but not for all sites particularly post-mining


hillslope.breaks <- uaa.dif %>%
  group_by(Data.Source,Site,Type) %>%
  mutate(max.mod = max(pred,na.rm=T)) %>% 
  filter(pred == max.mod) %>%
  arrange(Site,Type,Data.Source,UAA) %>%
  mutate(breaks = c('b1')) %>%
  dplyr::select(Site,Type,Data.Source,breaks,value=UAA,brk.derv=derv)



#Find the alluvial break which is where the UAA Slope plot rolls over in the dervative space this after the break 2 minimum and at the next rolling maximum. This is always before 10^4.5 by visual inspection
mybreaks <- function(sa.data){
  sa.data <- sa.data %>%
    filter(!is.na(pred)) %>%
    filter(UAA > 0) %>%
    arrange(UAA)
  bkpt <- breakpoints(log10(sa.data$pred) ~ log10(sa.data$UAA),breaks=1,h=0.49,hpc='foreach',het.reg=T,het.err=T)
  bk.points <-  sa.data %>%
    filter(index %in% bkpt$breakpoints)
  return((bk.points))
}






alluvial.breaks <- uaa.dif %>%
  left_join(hillslope.breaks,by=c('Data.Source','Site','Type')) %>%
  filter(UAA >= value) %>%
  filter(UAA < 10^4) %>%
  group_by(Data.Source,Site,Type) %>%
  mutate(index=1:n()) %>%
  nest() %>%
  mutate(alluvials=purrr::map(data,mybreaks)) %>%
  unnest(alluvials) %>%
  group_by(Data.Source,Site,Type) %>%
  mutate(breaks=c('b2')) %>%
  dplyr::select(Site,Type,Data.Source,breaks,value=UAA,brk.derv=derv)


fluvial.breaks <- uaa.dif %>%
  left_join(alluvial.breaks,by=c('Data.Source','Site','Type')) %>%
  filter(UAA >= value) %>%
  filter(UAA < 10^5.5) %>%
  group_by(Data.Source,Site,Type) %>%
  mutate(index=1:n()) %>%
  nest() %>%
  mutate(alluvials=purrr::map(data,mybreaks)) %>%
  unnest(alluvials) %>%
  group_by(Data.Source,Site,Type) %>%
  mutate(breaks=c('b3')) %>%
  dplyr::select(Site,Type,Data.Source,breaks,value=UAA,brk.derv=derv)



sa.breaks<- bind_rows(hillslope.breaks,alluvial.breaks,fluvial.breaks) %>%
  arrange(Site,Data.Source,value)

sa.brk.wide <- sa.breaks %>%
  dplyr::select(-brk.derv) %>%
  spread(key=breaks,value=value)


sa.mine.breaks <- sa.breaks %>%
  filter(Type=='Mined') %>%
  arrange(Site,Data.Source,Type) %>%
  mutate(logb=log10(value))

sa.unmine.breaks  <- sa.breaks %>%
  filter(Type!='Mined') %>%
  arrange(Site,Data.Source,Type)


write_csv(sa.breaks,path='Figures2018/sa.breaks.csv')
```



### Region slopes
```{r}

uaa.brk <- uaa %>%
  left_join(sa.brk.wide,by=c('Site',"Data.Source",'Type')) 

summary(uaa.brk)

sa.zone.lm <- function(sa.data){
  mod <- lm(log10(Slope) ~ log10(UAA),data=sa.data)
  keys <- tibble(adj.r.squared=glance(mod)$adj.r.squared,
                 p.value=glance(mod)$p.value,
                 reg.slope=tidy(mod)$estimate[2])
  return(keys)
}


sa.z2<- uaa.brk %>%
  filter(UAA > b1 & UAA < b2) %>%
  group_by(Site,Data.Source,Type) %>%
  nest() %>%
  mutate(zone = 'z2') %>%
  mutate(mods = map(data,sa.zone.lm)) %>%
  unnest(mods) %>%
  select(-data) %>%
  arrange(Site,Data.Source)
sa.z2


sa.z23 <- uaa.brk %>%
  filter(UAA > b1 ) %>%
  group_by(Site,Data.Source,Type) %>%
  nest() %>%
  mutate(zone = 'z23') %>%
  mutate(mods = map(data,sa.zone.lm)) %>%
  unnest(mods) %>%
  select(-data) %>%
  arrange(Site,Data.Source)
sa.z23

sa.z3 <- uaa.brk %>%
  filter(UAA > b2 & UAA <  b3) %>%
  group_by(Site,Data.Source,Type) %>%
  nest() %>%
  mutate(zone = 'z4') %>%
  mutate(mods = map(data,sa.zone.lm)) %>%
  unnest(mods) %>%
  select(-data)
  
sa.z4 <-  uaa.brk %>%
  filter(UAA >  b3) %>%
  group_by(Site,Data.Source,Type) %>%
  nest() %>%
  mutate(zone = 'z4') %>%
  mutate(mods = map(data,sa.zone.lm)) %>%
  unnest(mods) %>%
  select(-data)
sa.z4  

zone.regressions <- bind_rows(sa.z2,sa.z3,sa.z23,sa.z4)
write_csv(zone.regressions,path='Figures2018/sa.zone.regressions.csv')

```


## FInal SA Plots
```{r}

sa.breaks$Site <- gsub('Ref','',sa.breaks$Site)
sa.all <- uaa %>%
  select(Site,Type,Data.Source,UAA,Slope) %>%
  ungroup() %>%
  mutate(Site = gsub('Ref','',Site)) %>%
  ggplot(.,aes(x=UAA,y=Slope,color=interaction(Data.Source,Type))) + 
  geom_point(size=1) + 
  stat_smooth(method='loess',span=0.4,se=F) + 
  geom_vline(data=sa.breaks,aes(xintercept=value,color=interaction(Data.Source,Type))) + 
  facet_grid(Type~Site,scales='free_y') + 
  scale_color_manual(name='Data Source',values=c('red','blue','Orange3','Purple4')) + 
  theme(legend.position='top',legend.direction='horizontal') + 
  ylab('Slope (m/m)') +
  xlab(expression(paste('Upslope Accumulated Area (',m^2,')'))) + 
  scale_x_log10(breaks=trans_breaks("log10", function(x) 10^x),
              labels = trans_format("log10", math_format(10^.x))) + 
  scale_y_log10(limits=c(0.01,1),breaks=c(0.01,0.1,1))


pdf(file='Figures2018/SA.All.pdf',width=10,height=6)
sa.all

dev.off()


```


## SA Breaks on rasters
```{r}
library(plot3D)
library(doMC)
names(all.list)[2] <- 'WhiteOakRef'
registerDoMC(5)

foreach(i=1:length(all.list)) %dopar% {
  library(raster)
  library(tidyverse)
  p <- all.list[[i]]
  name<-names(all.list)[[i]]

old.breaks <- sa.breaks %>%
  filter(Site %in% name) %>%
  filter(Data.Source == 'Historic')

new.breaks <- sa.breaks %>%
  filter(Site %in% name) %>%
  filter(Data.Source != 'Historic')


old.e <- p[[4]]
old.a <- p[[10]]

old.zones <- cut(old.a,breaks=c(0,old.breaks$value/10,maxValue(old.a)))



new.e <- p[[1]]
new.a <- p[[9]]
new.zones <- cut(new.a,breaks=c(0,old.breaks$value/10,maxValue(new.a)))

png(filename=paste('Figures2018/RasterZones/',name,'Zones.png',sep=''),width=10,height=6,units='in',res=200)
  par(mfrow=c(1,2))
  plot(old.e,col=gray.colors(50,start=0.1,end=0.8),main=paste('Historic',name))
  plot(old.zones,col=c(NA,'purple2','red','black'),add=T,legend=F)
  legend('top',col=c(NA,'purple2','red','black'),horiz=T,
         legend=c('Zone 1','Zone 2','Zone 3','Zone 4'),pch=15)
  
  
  
  plot(new.e,col=gray.colors(50,start=0.1,end=0.8),main=paste('Current',name))
  plot(new.zones,col=c(NA,'purple2','red','black'),add=T,legend=F)
  legend('top',col=c(NA,'purple2','red','black'),horiz=T,
         legend=c('Zone 1','Zone 2','Zone 3','Zone 4'),pch=15)
dev.off()
}



```




# Cumulative area distribution


```{r}
#Cut uaa into a sequential cad with a equally spaced sequence (equal in log space)

cad <- long.df %>%
  dplyr::filter(fdr.type=='f.inf') %>%
  dplyr::filter(Data!='Elev') %>%
  #Sites less than 6km2 get smaller cut break
  select(Site,Type,Data,Data.Source,value,index) %>%
  spread(key=Data,value) %>%
  mutate(area.m2 = round(UAA*10,2)) %>%
  group_by(Site,Data.Source) %>%
  mutate(area.bins = cut(area.m2,breaks=unique(area.m2)))%>%
  ungroup() %>%
  group_by(Site,Type,Data.Source,area.bins) %>%
  dplyr::summarize(UAA=mean(area.m2,na.rm=T),
                   UAA.sd = sd(area.m2,na.rm=T)) %>%
  group_by(Site,Type,Data.Source,UAA) %>%
  summarise(Freq=n()) %>%
  arrange(Site,Type,Data.Source,desc(UAA)) %>%
  mutate(Cume_Freq=(cumsum(Freq)/sum(Freq))) %>%
  mutate(revuaa=rev(UAA)) %>%
  mutate(smooth.freq=runmed(Cume_Freq,5)) 
  


```


## Cad breaks

```{r}


mycad.breaks <- function(cad.data){
  cad.model <- cad.data %>%
    filter(UAA > 0) %>%
    arrange(UAA)
  bkpt <- Fstats(log10(cad.model$Cume_Freq) ~ log10(cad.model$UAA),from=0.5)
  bk.points <-  cad.data %>%
    filter(index %in% bkpt$breakpoint)
  return((bk.points))
}



#Data density for CAD is much higher than SA so this takes ~ 10 minutes to run
#Shortened the runtime by trimming data to a region that captures all breaks across all sites when run across full data. 
diffusecad <- cad %>%
  filter(UAA < 5000 ) %>%
  group_by(Data.Source,Site,Type) %>%
  mutate(index=1:n()) %>%
  nest() %>%
  mutate(hills=purrr::map(data,mycad.breaks)) %>%
  unnest(hills) %>%
  group_by(Data.Source,Site,Type) %>%
  mutate(breaks=c('b1')) %>%
  dplyr::select(Site,Type,Data.Source,breaks,value=UAA)

incisioncad <- cad %>%
  left_join(diffusecad,by=c('Site','Type','Data.Source')) %>%
  filter(UAA > value+1000 & UAA < 10^5) %>%
  mutate(index=1:n()) %>%
  nest() %>%
  mutate(incise=purrr::map(data,mycad.breaks)) %>%
  unnest(incise) %>%
  group_by(Data.Source,Site,Type) %>%
  mutate(breaks=c('b2')) %>%
  dplyr::select(Site,Type,Data.Source,breaks,value=UAA)


stemcad <- cad %>%
  left_join(incisioncad,by=c('Site','Type','Data.Source')) %>%
  filter(UAA > 10^5.3) %>%
  mutate(index=1:n()) %>%
  nest() %>%
  mutate(incise=purrr::map(data,mycad.breaks)) %>%
  unnest(incise) %>%
  group_by(Data.Source,Site,Type) %>%
  mutate(breaks=c('b3')) %>%
  dplyr::select(Site,Type,Data.Source,breaks,value=UAA)


cad.breaks <- bind_rows(diffusecad,incisioncad,stemcad) %>%
  ungroup() %>%
   mutate(Site = gsub('Ref','',Site))


cad.g <- cad %>% 
  ungroup() %>%
  mutate(Site = gsub('Ref','',Site)) %>%
ggplot(.,aes(x=UAA,y=Cume_Freq,color=interaction(Data.Source,Type),size=Data.Source)) + 
  geom_point(shape=1) + 
  scale_size_manual(name='',guide=F,values=c(1.2,0.4)) +
  scale_x_log10(breaks=trans_breaks("log10", function(x) 10^x),
              labels = trans_format("log10", math_format(10^.x)))  + scale_y_log10(limits=c(0.001,1),breaks=c(0.001,0.01,0.1,1)) + 
  facet_grid(Type~Site) + 
  geom_vline(data=cad.breaks,aes(xintercept=value,color=interaction(Data.Source,Type))) + 
  theme(legend.position = 'top',legend.direction = 'horizontal') +
  scale_color_manual(name='Data Source',values=c('red','blue','orange3','purple4')) +
  ylab('P (A>A*)') + 
  xlab(expression(paste('Upslope Accumulated Area (',m^2,')'))) 


png(filename='Figures2018/Fig5_CAD.All2decimals.png',width=10,height=6,units='in',res=300)
cad.g

dev.off()
```


## UAA Density
```{r}

pdf(file='Figures2018/UAA.Density.pdf',width=10,height=5)
cad %>% 
  ggplot(.,aes(x=UAA, fill=Data.Source)) +
  geom_density(alpha=0.5) + 
  scale_x_log10() + 
  scale_fill_manual(values=c('Red','Blue')) + 
  facet_wrap(~Site,ncol=5) + 
  theme(legend.position = 'top',legend.direction='horizontal')  

dev.off()

```



# Energy Index

## Figure 6 EI Plots

```{r}
ei <- long.df %>%
  dplyr::filter(fdr.type=='f.inf') %>%
  dplyr::filter(Data!='Elev') %>%
  #Sites less than 6km2 get smaller cut break
  select(Site,Type,Data,Data.Source,value,index) %>%
  spread(key=Data,value) %>%
  mutate(area.m2 = round(UAA*10,1)) %>%
  mutate(ei=round(Slope*area.m2,1)) %>%
  group_by(Site,Data.Source) %>%
  mutate(ei.bins = cut(ei,breaks=unique(ei)))%>%
  group_by(Site,Type,Data.Source,ei.bins) %>%
  dplyr::summarize(UAA=mean(area.m2,na.rm=T),
                   UAA.sd = sd(area.m2,na.rm=T),
                   ei=round(mean(ei,na.rm=T),1)) %>%
  group_by(Site,Type,Data.Source,ei) %>%
  summarise(Freq=n()) %>%
  arrange(Site,Type,Data.Source,desc(ei)) %>%
  mutate(Cume_Freq=(cumsum(Freq)/sum(Freq))) %>%
  mutate(revei=rev(ei))

ei.g <- ei %>% 
  filter(ei > 0.01) %>%
  ungroup() %>%
  mutate(Site = gsub('Ref','',Site)) %>%
ggplot(.,aes(x=ei,y=Cume_Freq,color=interaction(Data.Source,Type),size=Data.Source)) + 
  geom_point(shape=1) + 
  scale_size_manual(name='',guide=F,values=c(1.2,0.4)) +
  scale_x_log10(breaks=trans_breaks("log10", function(x) 10^x),
              labels = trans_format("log10", math_format(10^.x)))  + scale_y_log10(limits=c(0.0005,1),breaks=c(0.001,0.01,0.1,1)) + 
  facet_grid(Type~Site) + 
  theme(legend.position = 'top',legend.direction = 'horizontal') +
  scale_color_manual(name='Data Source',values=c('red','blue','orange3','purple4')) +
  ylab('EI (EI>EI*)') + 
  xlab(expression(paste('Energy Index (S*A)')))

ei.g

png(filename='Figures2018/Fig_6_EI.Cume.png',width=10,height=6,units='in',res=300)
ei.g
dev.off()

```



# 3D plots

```{r}

spruce <- all.list[[6]]


newdem <- spruce[[1]]
olddem <- spruce[[4]]
newfac <- spruce[[9]]
oldfac <- spruce[[10]]
newslp <- spruce[[5]]
oldslp <- spruce[[6]]
newei <- newfac*newslp
oldei <- oldfac*oldslp


#Convert rasters to matrices
old.s <- as.matrix(oldslp)
new.s <- as.matrix(newslp)
old.ei <- log10(as.matrix(oldei))
new.ei <- log10(as.matrix(newei))
old.ei[old.ei==-Inf] <- -1
new.ei[new.ei==-Inf] <- -1


old.m.na <- as.matrix(olddem)
new.m.na <- as.matrix(newdem)
olddem[is.na(olddem)] <- minValue(olddem)-1
newdem[is.na(newdem)] <- minValue(newdem)-1
old.m <- as.matrix(olddem)
new.m <- as.matrix(newdem)
old.f.m <- log10(as.matrix(oldfac))
old.f.m[old.f.m==-Inf] <- 1
new.f.m <- log10(as.matrix(newfac))
new.f.m[new.f.m==-Inf] <- 1
x <- 1:nrow(old.m)*10
y <- 1:ncol(old.m)*10
#Get zlim values
lim <- function(x,y){
    max1 <- maxValue(x)
    min1 <- minValue(x)
    max2 <- maxValue(y)
    min2 <- minValue(y)
    zlims <-c(floor(min(c(min1,min2))),ceiling(max(c(max1,max2))))
    return(zlims)
}
  
png(filename='Figures2018/3D_4_indices.png',width=12,height=10,units='in',res=300)
#Verbose code to get exactly the plot I want. 
cols <-colorRampPalette(c('forestgreen','brown2'))
bord <- rgb(0,0,0,0)



par(mar=c(0,0,0,0),mgp=c(1.8,0.5,0),cex=1.5,cex.lab=1.5,cex.axis=1.3)

mx <- matrix(c(1,1,2,2,3,4,4,5,5,6,7,7,8,8,9,10,10,11,11,12),4,5,byrow=T)
layout(mx)

#OldDEM
l.dist <- -0.05
theta <- -90.5
phi <- 45
shade=.65
lphi=0
ltheta=-135
# par(mfrow=c(1,2))
# hist(old.f.m,col='grey',ylim=c(0,6000),breaks=seq(0,7,by=.1))
# hist(new.f.m,col='grey',ylim=c(0,6000),breaks=seq(0,7,by=.1))
# 
zlims <- lim(olddem,newdem)



## Old DEM, Top Left
persp3D(x=x, y=y,z=old.m,col=c('gray30'),lighting=T,colkey=list(plot=FALSE),theta=theta,phi=phi,
        scale = FALSE, shade = 1,clab='Elev. (m)',axes=F,zlim=zlims,box=F,
        ticktype='detailed',xlab='North (m)',ylab='East (m)',zlab='Elev (m)',inttype=2,expand=2)

persp3D(x=x, y=y,z=old.m.na,col=c(bord,cols(200)),
        colkey=list(side=4,line.clab=1,dist=l.dist,width=0.75,length=0.5,mgp=c(2,0.6,0)),
        lighting=T,add=T,clim=zlims,zlim=zlims,box=F,
        scale = FALSE, shade = 0.6,clab='Elev. (m)',expand=2,
        inttype=2)


#NewDEM, Top Middle
persp3D(x=x, y=y,z=new.m,col=c('gray30'),lighting=T,colkey=list(plot=FALSE),theta=theta,phi=phi,
        scale = FALSE, shade = 1,clab='Elev. (m)',axes=F,zlim=zlims,box=F,
        ticktype='detailed',xlab='North (m)',ylab='East (m)',zlab='Elev (m)',inttype=2,expand=2)
persp3D(x=x, y=y,z=new.m.na,col=c(bord,cols(200)),colkey=list(plot=F),
        lighting=T,add=T,clim=zlims,zlim=zlims,box=F,
        scale = FALSE, shade = 0.6,clab='Elev. (m)',expand=2,
        inttype=2)


#Elevation histogram, top right
hist.mar <- c(3,0,0.5,2)
par(mar=hist.mar)
hist(old.m.na,breaks=seq(zlims[1],zlims[2],length.out=50),xlim=zlims,col='blue',ylim=c(0,4500),xlab='Elevation (m)',ylab='Frequency',main='')
reds2 <- makeTransparent('red',alpha=.8)
hist(new.m.na, breaks=seq(zlims[1],zlims[2],length.out=50),xlim=zlims,col=reds2,add=T,density=40)




par(mar=c(0,0,0,0))
#OldSlope

slims <- c(0,2)
scols <- colorRampPalette(c('yellow3','red','red4'))
persp3D(x=x, y=y,z=old.m,col=c('gray30'),lighting=T,colkey=list(plot=FALSE),theta=theta,phi=phi,
        scale = FALSE, shade = 1,clab='Elevation (m)',axes=F,zlim=zlims,box=F,
        ticktype='detailed',xlab='North (m)',ylab='East (m)',zlab='Elev (m)',inttype=2,expand=2)
persp3D(x=x, y=y,z=old.m.na,col=c(scols(200)),colvar = old.s,
        colkey=list(side=4,line.clab=1,dist=l.dist,width=0.75,length=0.5,mgp=c(2,0.6,0)),
        add=T,clim=slims,zlim=zlims,box=F,NAcol=bord,
        scale = FALSE,clab='Slope (m/m)',expand=2,shade=shade,lphi=lphi,ltheta=ltheta,
        inttype=2)

#NewSlope
persp3D(x=x, y=y,z=new.m,col=c('gray30'),lighting=T,colkey=list(plot=FALSE),theta=theta,phi=phi,
            scale = FALSE, shade = 1,clab='Elevation (m)',axes=F,zlim=zlims,box=F,
            ticktype='detailed',xlab='North (m)',ylab='East (m)',zlab='Elev (m)',inttype=2,expand=2)
persp3D(x=x, y=y,z=new.m.na,col=c(scols(200)),colvar=new.s,NAcol=bord,
        colkey=list(plot=F),add=T,zlim=zlims,box=F,shade=shade,lphi=lphi,ltheta=ltheta,
        scale = FALSE,clab='Slope (m/m)',expand=2,inttype=2,clims=slims)


par(mar=hist.mar)
hist(old.s,breaks=seq(0,2.5,length.out=100),xlim=c(0,1.2),col='blue',ylim=c(0,5000),xlab='Slope (m/m)',ylab='Frequency',main='')
hist(new.s, breaks=seq(0,2.5,length.out=100),xlim=c(0,1.2),col=reds2,add=T,density=40)




#OldFAC
par(mar=c(0,0,0,0))
flims <- log10(lim(newfac,oldfac))
cols.f <- colorRampPalette(c('lightblue','darkblue','purple4','mediumvioletred'))
persp3D(x=x, y=y,z=old.m,col=c('gray30'),lighting=T,colkey=list(plot=FALSE),theta=theta,phi=phi,
            scale = FALSE, shade = 1,clab='Elevation (m)',axes=F,zlim=zlims,box=F,
            ticktype='detailed',xlab='North (m)',ylab='East (m)',zlab='Elev (m)',inttype=2,expand=2)
persp3D(x=x, y=y,z=old.m.na,col=c('white',cols.f(50)),colvar=(old.f.m),
        colkey=list(side=4,line.clab=1,dist=l.dist,width=0.75,length=0.5,mgp=c(2,0.6,0)),
        add=T,zlim=zlims,box=F,shade=shade,lphi=lphi,ltheta=ltheta,
        scale = FALSE,clab=expression(bold(paste('Log UAA (',m^2,')',sep=''))),expand=2,clims=flims,
        inttype=2)



#NewFAC
persp3D(x=x, y=y,z=new.m,col=c('gray30'),lighting=T,colkey=list(plot=FALSE),theta=theta,phi=phi,
            scale = FALSE, shade = 1,clab='Elevation (m)',axes=F,zlim=zlims,box=F,
            ticktype='detailed',xlab='North (m)',ylab='East (m)',zlab='Elev (m)',inttype=2,expand=2)
persp3D(x=x, y=y,z=new.m.na,col=c('white',cols.f(100)),colvar=new.f.m,
        colkey=list(plot=F),add=T,zlim=zlims,box=F,
        scale = FALSE,clab='',shade=shade,lphi=lphi,ltheta=ltheta,
        expand=2,inttype=2,clims=flims)

old.f <- 10^old.f.m

par(mar=hist.mar)
hist(old.f.m,breaks=seq(1,6,length.out=100),col='blue',ylim=c(0,6200),
  xlab=expression(paste('UAA (',m^2,')',sep='')),ylab='Frequency',main='',xaxt='n')
axis(1,at=c(1,2,3,4,5,6),labels=c(expression(10^1),expression(10^2),expression(10^3),expression(10^4),expression(10^5),expression(10^6)))
hist(new.f.m, breaks=seq(1,6,length.out=100),xlim=c(1,6),col=reds2,add=T,density=40)
legend(x=10^3,y=3000,pch=c(15,15),col=c('blue',reds2),legend=c('Pre-Mining','Post-Mining'),cex=1.5)

#OldEI
par(mar=c(0,0,0,0))
ei.lims <- c(-2,5)
ei.cols <- colorRampPalette(c('tan2','tan4','cyan','blue','green','green'))
persp3D(x=x, y=y,z=old.m,col=c('gray30'),lighting=T,colkey=list(plot=FALSE),theta=theta,phi=phi,
        scale = FALSE, shade = 1,clab='Elevation (m)',axes=F,zlim=zlims,box=F,
        ticktype='detailed',xlab='North (m)',ylab='East (m)',zlab='Elev (m)',inttype=2,expand=2)
persp3D(x=x, y=y,z=old.m.na,col=c(ei.cols(200)),colvar = old.ei,NAcols=bord,
        colkey=list(side=4,line.clab=1,dist=l.dist,width=0.75,length=0.5,mgp=c(2,0.6,0)),
        add=T,clim=ei.lims,zlim=zlims,box=F,NAcol=bord,shade=shade,lphi=lphi,ltheta=ltheta,
        scale = FALSE,clab='Log EI',expand=2,
        inttype=2)


#NewEI
#Shorten the color ramp 
new.ei[new.ei < -2] <- -2

persp3D(x=x, y=y,z=new.m,col=c('gray30'),lighting=T,colkey=list(plot=FALSE),theta=theta,phi=phi,
            scale = FALSE, shade = 1,clab='Elevation (m)',axes=F,zlim=zlims,box=F,
            ticktype='detailed',xlab='North (m)',ylab='East (m)',zlab='Elev (m)',inttype=2,expand=2)
persp3D(x=x, y=y,z=new.m.na,col=c(ei.cols(200)),colvar=new.ei,NAcol=bord,
        colkey=list(plot=F),add=T,zlim=zlims,box=F,shade=shade,lphi=lphi,ltheta=ltheta,
        scale = FALSE,clab='Slope (m/m)',expand=2,inttype=2,clims=ei.lims)



par(mar=hist.mar)
hist(old.ei,breaks=seq(-2.1,6,length.out=100),col='blue',ylim=c(0,6100),
  xlab='Energy Index',ylab='Frequency',main='',xaxt='n')
axis(1,at=c(-1,1,3,5,7),labels=c(expression(10^-1),expression(10^1),expression(10^3),expression(10^5),expression(10^7)))
hist(new.ei, breaks=seq(-2.1,6,length.out=100),xlim=c(0,7.1),col=reds2,add=T,density=40)
#legend(x=3,y=5000,pch=c(15,15),col=c('gray20',reds2),legend=c('Pre-Mining','Post-Mining'))

dev.off()
```


#Supplement way too much detail

##Check for differences between flow direction algorithm (f8 or f.infinity)

###Flow direction differnces in Uplsope Accumulated Area (UAA) for reference sites
```{r, fig.width=10,fig.height=6,eval=F}

load('UAA.E.Slope.Ref.RData')
load('ras.stack.ref.RData')
load('Long.DF.RData')



#Elevation is not impacted. 
fdr.diff <- long.df %>%
  filter(Data != 'Elev') %>% 
  select(Watershed,Site,Data,Data.Source,fdr.type,value,index,Type) %>%
  spread(key=fdr.type,value=value) %>%
  group_by(Watershed,Data,Data.Source) %>%
  #Account for the difference in pixel counting methods by dividng f.inf by 10 for UAA
  mutate(f.inf.cor=ifelse(Data == 'UAA',f.inf/10,f.inf)) %>%
  mutate(fdr.dif=f.8-f.inf) %>%
  #Filter out errors where watershed sizes differ giving very large FDR differences
  filter(fdr.dif > -500 & fdr.dif < 500) %>%
  ungroup(.) 

fdr.diff %>%
  filter(Data == 'UAA') %>%
ggplot(.,aes(x=fdr.dif,color=Data.Source)) + stat_density(geom='line',size=1.2) +
  facet_wrap(~Watershed + Type,scales='fixed') + 
  xlab('Flow Accumulation Difference in m2 (F.8-F.Inf)') + 
  theme(legend.position=c(.8,.15)) +
  scale_color_manual(values=c('#762a83','#1b7837','#b2182b','#2166ac'))


```




###Flow Direction Differences in Slope
```{r, fig.width=10,fig.height=6,eval=F}

fdr.diff %>%
  filter(Data == 'Slope') %>%
ggplot(.,aes(x=fdr.dif,color=Data.Source)) + stat_density(geom='line',size=1.2) +
  facet_wrap(~Watershed + Type,scales='fixed') + 
  xlab('Slope in m/m (F.8-F.Inf)') + 
  theme(legend.position=c(.8,.2)) +
  scale_color_manual(values=c('#762a83','#1b7837','#b2182b','#2166ac'))

```


